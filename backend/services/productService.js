import { getDb, collections } from '../database/mongodb.js';

export class ProductService {
  /**
   * Sync products from Shopify to MongoDB
   * Stores light product data + AI data only
   */
  async syncProducts(shopId, shopifyProducts) {
    const db = await getDb();
    const productsCollection = db.collection(collections.products);
    
    const lightProducts = shopifyProducts.map(product => ({
      shopId,
      productId: product.id,
      title: product.title,
      description: product.body_html || '',
      tags: product.tags ? product.tags.split(',').map(tag => tag.trim()) : [],
      vendor: product.vendor || '',
      productType: product.product_type || '',
      aiData: {
        // Store AI-relevant features for similarity matching
        keywords: this.extractKeywords(product.title + ' ' + (product.body_html || '')),
        category: product.product_type || '',
        price: product.variants?.[0]?.price || '0',
        color: this.extractColor(product),
        style: this.extractStyle(product),
        brand: product.vendor || '',
        features: this.extractFeatures(product),
        embedding: null // Will be generated by AI engine
      },
      createdAt: new Date(),
      updatedAt: new Date()
    }));

    // Bulk upsert products
    const operations = lightProducts.map(product => ({
      updateOne: {
        filter: { shopId: product.shopId, productId: product.productId },
        update: { $set: product },
        upsert: true
      }
    }));

    await productsCollection.bulkWrite(operations);
    return lightProducts.length;
  }

  /**
   * Get products by shop ID for AI engine
   */
  async getProductsByShop(shopId) {
    const db = await getDb();
    const productsCollection = db.collection(collections.products);
    
    return await productsCollection.find({ shopId }).toArray();
  }

  /**
   * Update product AI data
   */
  async updateProductAIData(shopId, productId, aiData) {
    const db = await getDb();
    const productsCollection = db.collection(collections.products);
    
    await productsCollection.updateOne(
      { shopId, productId },
      { 
        $set: { 
          'aiData': aiData,
          updatedAt: new Date()
        }
      }
    );
  }

  /**
   * Extract keywords from product title and description
   */
  extractKeywords(text) {
    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should']);
    
    return text.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.has(word))
      .slice(0, 20); // Limit to top 20 keywords
  }

  /**
   * Extract color from product data
   */
  extractColor(product) {
    const colors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'orange', 'purple', 'pink', 'brown', 'gray', 'grey', 'navy', 'teal', 'maroon', 'beige', 'cream', 'gold', 'silver'];
    const text = (product.title + ' ' + (product.body_html || '')).toLowerCase();
    
    for (const color of colors) {
      if (text.includes(color)) {
        return color;
      }
    }
    return null;
  }

  /**
   * Extract style from product data
   */
  extractStyle(product) {
    const styles = ['casual', 'formal', 'sport', 'elegant', 'vintage', 'modern', 'classic', 'minimalist', 'bohemian', 'preppy', 'grunge'];
    const text = (product.title + ' ' + (product.body_html || '') + ' ' + (product.tags || '')).toLowerCase();
    
    for (const style of styles) {
      if (text.includes(style)) {
        return style;
      }
    }
    return null;
  }

  /**
   * Extract features from product data
   */
  extractFeatures(product) {
    const features = [];
    const text = (product.title + ' ' + (product.body_html || '') + ' ' + (product.tags || '')).toLowerCase();
    
    const featurePatterns = [
      /waterproof|water resistant/,
      /breathable/,
      /washable/,
      /stretch|elastic/,
      /insulated|warm/,
      /lightweight/,
      /durable/,
      /adjustable/,
      /portable|foldable/,
      /wireless|bluetooth/
    ];

    featurePatterns.forEach((pattern, index) => {
      if (pattern.test(text)) {
        features.push(['waterproof', 'breathable', 'washable', 'stretch', 'insulated', 'lightweight', 'durable', 'adjustable', 'portable', 'wireless'][index]);
      }
    });

    return features;
  }
}